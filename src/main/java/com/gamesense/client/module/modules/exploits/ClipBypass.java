package com.gamesense.client.module.modules.exploits;

import com.gamesense.api.event.events.PlayerMoveEvent;
import com.gamesense.api.setting.values.BooleanSetting;
import com.gamesense.api.setting.values.IntegerSetting;
import com.gamesense.api.setting.values.ModeSetting;
import com.gamesense.client.module.Category;
import com.gamesense.client.module.Module;
import me.zero.alpine.listener.EventHandler;
import me.zero.alpine.listener.Listener;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.util.math.Vec3d;

import java.util.Arrays;

@Module.Declaration(name = "ClipBypass", category = Category.Exploits)
public class ClipBypass extends Module {
    ModeSetting flight = registerMode("Mode", Arrays.asList("Flight", "Clip", "Relative"), "Clip");
    IntegerSetting packets = registerInteger("Packets", 80, 1, 300);
    BooleanSetting flat = registerBoolean("Flat", false);
    BooleanSetting forceY = registerBoolean("Force Y", false);
    IntegerSetting forcedY = registerInteger("Y Level", 80, -50, 300);
    BooleanSetting disable = registerBoolean("Disable", false);
    IntegerSetting speed = registerInteger("XZ Speed", 7, 0, 500);
    IntegerSetting speedY = registerInteger("Y Speed", 7, 0, 500);
    BooleanSetting update = registerBoolean("Update Position Client Side", false);
    IntegerSetting x = registerInteger("X", 0, -256, 256);
    IntegerSetting y = registerInteger("Y", 0, -256, 256);
    IntegerSetting z = registerInteger("Z", 0, -256, 256);
    int num = 0;
    private double startFlat = 0.0;
    @EventHandler
    private final Listener<PlayerMoveEvent> playerMoveEventListener = new Listener<>(event -> {

        event.setY(-0.0001);

        switch (flight.getValue()) {
            case "Flight":

                double yposition = mc.player.posY + speedY.getValue();

                if (forceY.getValue()) yposition = forcedY.getValue().doubleValue();

                Vec3d dir = new Vec3d(Math.cos((mc.player.rotationYaw + 90f) * Math.PI / 180.0f), 0.0, Math.sin((mc.player.rotationYaw + 90f) * Math.PI / 180.0f));

                if (mc.gameSettings.keyBindJump.isKeyDown()) {
                    for (int i = 0; i < packets.getValue(); i++) {

                        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, yposition, mc.player.posZ, false));
                        if (update.getValue()) mc.player.setPosition(mc.player.posX, yposition, mc.player.posZ);
                        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY + 0.05, mc.player.posZ, false));
                        if (update.getValue())
                            mc.player.setPosition(mc.player.posX, mc.player.posY + 0.05, mc.player.posZ);
                    }
                } else if (mc.gameSettings.keyBindSneak.isKeyDown()) {

                    for (int i = 0; i < packets.getValue(); i++) {


                        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, yposition, mc.player.posZ, false));
                        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY + 0.05, mc.player.posZ, false));
                        if (update.getValue())
                            mc.player.setPosition(mc.player.posX, mc.player.posY + 0.05, mc.player.posZ);
                    }

                }


                if (mc.gameSettings.keyBindForward.isKeyDown()) {
                    mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX + dir.x * speed.getValue(), yposition, mc.player.posZ + dir.z * speed.getValue(), false));
                    if (update.getValue()) mc.player.setPosition(mc.player.posX, yposition, mc.player.posZ);
                    if (flat.getValue()) {
                        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, startFlat, mc.player.posZ, false));
                        if (update.getValue()) mc.player.setPosition(mc.player.posX, startFlat, mc.player.posZ);
                    }
                    mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY + 0.05, mc.player.posZ, false));
                    if (update.getValue()) mc.player.setPosition(mc.player.posX, mc.player.posY + 0.05, mc.player.posZ);
                }

                num++;

                if (num == 80 && disable.getValue()) {
                    disable();
                }

                break;
            case "Clip":

                if (mc.gameSettings.keyBindJump.isKeyDown()) {
                    for (int i = 0; i < packets.getValue(); i++) {

                        yposition = mc.player.posY + speedY.getValue();

                        if (forceY.getValue()) yposition = forcedY.getValue().doubleValue();

                        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, yposition, mc.player.posZ, false));
                        if (update.getValue()) mc.player.setPosition(mc.player.posX, yposition, mc.player.posZ);
                        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY + 0.05, mc.player.posZ, false));
                        if (update.getValue())
                            mc.player.setPosition(mc.player.posX, mc.player.posY + 0.05, mc.player.posZ);
                    }
                }

                break;
            case "Relative":

                for (int i = 0; i < packets.getValue(); i++) {

                    mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX + x.getValue(), mc.player.posY + y.getValue(), mc.player.posZ + z.getValue(), false));
                    if (update.getValue())
                        mc.player.setPosition(mc.player.posX, mc.player.posY + y.getValue(), mc.player.posZ);
                    mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY + 0.05, mc.player.posZ, false));
                    if (update.getValue()) mc.player.setPosition(mc.player.posX, mc.player.posY + 0.05, mc.player.posZ);
                }

                break;
        }

        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY, mc.player.posZ, true)); // OnGround true
        if (update.getValue())
            mc.player.setPosition(mc.player.posX, mc.player.posY, mc.player.posZ); // Redundant as just for setting onGround but no reason not to
    });

    public void onEnable() {
        startFlat = mc.player.posY;
        num = 0;
    }
}


