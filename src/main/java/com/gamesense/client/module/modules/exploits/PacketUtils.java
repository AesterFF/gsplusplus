package com.gamesense.client.module.modules.exploits;

import com.gamesense.api.event.events.BlockResetEvent;
import com.gamesense.api.event.events.PacketEvent;
import com.gamesense.api.setting.values.BooleanSetting;
import com.gamesense.client.module.Category;
import com.gamesense.client.module.Module;
import me.zero.alpine.listener.EventHandler;
import me.zero.alpine.listener.Listener;
import net.minecraft.block.BlockContainer;
import net.minecraft.init.Items;
import net.minecraft.network.play.client.*;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraftforge.fml.common.network.internal.FMLProxyPacket;

@Module.Declaration(name = "PacketUtils",category = Category.Exploits)
public class PacketUtils extends Module {

    private boolean shouldStop = false;

    BooleanSetting breakReset = registerBoolean("No Break Reset", false);
    BooleanSetting antiGap = registerBoolean("Anti Gap Fail", false);
    BooleanSetting noRotate = registerBoolean("No Rotate", false);
    BooleanSetting noSwing = registerBoolean("No Swing", false);
    BooleanSetting client = registerBoolean("Client", true , () -> noSwing.getValue());
    BooleanSetting server = registerBoolean("Server", false, () -> noSwing.getValue());
    BooleanSetting noInteract = registerBoolean("No Interact", false);
    BooleanSetting containerOnly = registerBoolean("Container Only", false, () -> noInteract.getValue());
    BooleanSetting onlyGapple = registerBoolean("Only Gapple", false      , () -> noInteract.getValue());

    @EventHandler
    private final Listener<PacketEvent.Send> sendListener = new Listener<>(event -> {
        if (event.getPacket() instanceof CPacketPlayerTryUseItemOnBlock && !mc.player.isSneaking() && noInteract.getValue()) {

            CPacketPlayerTryUseItemOnBlock packet = ((CPacketPlayerTryUseItemOnBlock) event.getPacket());

            if (containerOnly.getValue() && !(mc.world.getBlockState(packet.getPos()).getBlock() instanceof BlockContainer) ||
                    (onlyGapple.getValue() && mc.player.getHeldItemMainhand().getItem() != Items.GOLDEN_APPLE))
                return;

            mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, CPacketEntityAction.Action.START_SNEAKING));
            shouldStop = true;
        }
    });

    @EventHandler
    private final Listener<BlockResetEvent> blockResetEventListener = new Listener<>(event -> {

        if (breakReset.getValue())
            event.cancel();

    });

    @SuppressWarnings("unused")
    @EventHandler
    private final Listener<PacketEvent.PostSend> postSendListener = new Listener<>(event -> {
        if (event.getPacket() instanceof CPacketPlayerTryUseItemOnBlock && shouldStop && noInteract.getValue()) {

            CPacketPlayerTryUseItemOnBlock packet = ((CPacketPlayerTryUseItemOnBlock) event.getPacket());

            if (containerOnly.getValue() && !(mc.world.getBlockState(packet.getPos()).getBlock() instanceof BlockContainer))
                return;

            mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, CPacketEntityAction.Action.STOP_SNEAKING));
            shouldStop = false;
        }
    });

    @EventHandler
    private final Listener<PacketEvent.Receive> receiveListener = new Listener<>(event -> {


        if (event.getPacket() instanceof SPacketPlayerPosLook && noRotate.getValue()) {

            SPacketPlayerPosLook e = (SPacketPlayerPosLook) event.getPacket();

            e.pitch = mc.player.rotationPitch;
            e.yaw = mc.player.rotationYaw;


        }

    });

    @EventHandler
    private final Listener<PacketEvent.Send> listener = new Listener<>(event -> {
        if (event.getPacket() instanceof CPacketAnimation && server.getValue() && noSwing.getValue()) {

            event.cancel();

        }
    });

    @Override
    public void onUpdate() {
        if (mc.player.canEat(true) && mc.player.isSwingInProgress && mc.player.getHeldItemMainhand().getItem().equals(Items.GOLDEN_APPLE) && antiGap.getValue()) {

            mc.player.connection.sendPacket(new CPacketHeldItemChange(mc.player.inventory.currentItem));

        }

        if (client.getValue() && noSwing.getValue()) {

            mc.player.isSwingInProgress = false;
            mc.player.swingProgressInt = 0;
            mc.player.swingProgress = 0.0f;
            mc.player.prevSwingProgress = 0.0f;

        }
    }

}
